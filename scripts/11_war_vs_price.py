"""
Calculate WAR vs Price metrics for IPL 2025.

This script:
1. Loads player price data (generated by generate_2025_prices.py)
2. Loads 2025 WAR results (batter and bowler)
3. Maps players between datasets using fuzzy matching
4. Calculates value metrics:
   - Price per WAR (Cost efficiency)
   - WAR per Crore (Bang for buck)
5. Generates summary tables and analysis
"""

import pandas as pd
import numpy as np
from pathlib import Path
from difflib import get_close_matches
import re

def clean_name(name):
    """Normalize name for matching."""
    if not isinstance(name, str):
        return ""
    # Remove special chars, lowercase, strip whitespace
    name = re.sub(r'[^\w\s]', '', name).lower().strip()
    return name

def parse_price(price_str):
    """Convert price string (e.g., '18 Cr', '30 Lakh') to Crores (float)."""
    if not isinstance(price_str, str):
        return 0.0
    
    price_str = price_str.lower().strip()
    if 'cr' in price_str:
        return float(price_str.replace('cr', '').strip())
    elif 'lakh' in price_str:
        return float(price_str.replace('lakh', '').strip()) / 100
    return 0.0

def load_data(project_root):
    """Load price, WAR, and metadata."""
    print("Loading data...")
    
    # Load prices
    price_file = project_root / 'data' / 'IPL_2025_Players_List.csv'
    prices_df = pd.read_csv(price_file)
    prices_df['price_cr'] = prices_df['Price'].apply(parse_price)
    print(f"✓ Loaded prices for {len(prices_df)} players")
    
    # Load WAR data
    war_dir = project_root / 'results' / '2025_season'
    batter_war = pd.read_csv(war_dir / 'batter_war_2025.csv')
    bowler_war = pd.read_csv(war_dir / 'bowler_war_2025.csv')
    
    print(f"✓ Loaded {len(batter_war)} batters and {len(bowler_war)} bowlers (2025)")

    # Load metadata
    meta_file = project_root / 'data' / 'player_metadata.csv'
    metadata = pd.read_csv(meta_file)
    print(f"✓ Loaded metadata for {len(metadata)} players")
    
    return prices_df, batter_war, bowler_war, metadata

def map_players(prices_df, batter_war, bowler_war, metadata):
    """Map price list names to WAR data names using metadata."""
    print("\nMapping players...")
    
    # Standardize columns for merging
    b_war = batter_war[['batter_name', 'WAR', 'balls_faced']].rename(
        columns={'batter_name': 'player_name', 'WAR': 'batting_WAR', 'balls_faced': 'batting_balls'}
    )
    bo_war = bowler_war[['bowler_name', 'WAR', 'balls_bowled']].rename(
        columns={'bowler_name': 'player_name', 'WAR': 'bowling_WAR', 'balls_bowled': 'bowling_balls'}
    )
    
    # Merge WAR data
    war_df = pd.merge(b_war, bo_war, on='player_name', how='outer').fillna(0)
    war_df['total_WAR'] = war_df['batting_WAR'] + war_df['bowling_WAR']
    war_df['total_balls'] = war_df['batting_balls'] + war_df['bowling_balls']
    
    print(f"✓ Combined WAR data: {len(war_df)} unique players")
    
    # Create lookup dictionary
    # We want to map: Search Name -> cricWAR Name (player_name)
    lookup = {}
    
    # 1. Add mappings from metadata (Full Name -> cricWAR Name)
    # metadata has 'player_name' (matches WAR) and 'full_name'
    for _, row in metadata.iterrows():
        cricwar_name = row['player_name']
        full_name = row['full_name']
        
        if pd.notna(full_name):
            lookup[clean_name(full_name)] = cricwar_name
        
        # Also map the cricwar name itself
        lookup[clean_name(cricwar_name)] = cricwar_name

    # 2. Add mappings from WAR data (in case some are missing from metadata)
    for name in war_df['player_name'].unique():
        lookup[clean_name(name)] = name
        
    # Mapping
    mapped_data = []
    unmapped = []
    
    for _, row in prices_df.iterrows():
        price_name = row['Player Name']
        cleaned_price_name = clean_name(price_name)
        
        match_name = None
        match_type = None
        
        # 1. Exact match on cleaned name
        if cleaned_price_name in lookup:
            match_name = lookup[cleaned_price_name]
            match_type = "exact"
        else:
            # 2. Fuzzy match
            # Get close matches from cleaned keys
            matches = get_close_matches(cleaned_price_name, lookup.keys(), n=1, cutoff=0.85)
            if matches:
                match_name = lookup[matches[0]]
                match_type = "fuzzy"
        
        if match_name:
            # Get WAR data
            # Check if player exists in WAR data (might be in metadata but not in 2025 WAR)
            if match_name in war_df['player_name'].values:
                player_stats = war_df[war_df['player_name'] == match_name].iloc[0]
                mapped_data.append({
                    'price_name': price_name,
                    'cricwar_name': match_name,
                    'team': row['Team'],
                    'price_cr': row['price_cr'],
                    'total_WAR': player_stats['total_WAR'],
                    'batting_WAR': player_stats['batting_WAR'],
                    'bowling_WAR': player_stats['bowling_WAR'],
                    'match_type': match_type
                })
            else:
                # Player found in metadata but no WAR in 2025
                mapped_data.append({
                    'price_name': price_name,
                    'cricwar_name': match_name,
                    'team': row['Team'],
                    'price_cr': row['price_cr'],
                    'total_WAR': 0.0,
                    'batting_WAR': 0.0,
                    'bowling_WAR': 0.0,
                    'match_type': 'metadata_only'
                })
        else:
            unmapped.append(price_name)
            mapped_data.append({
                'price_name': price_name,
                'cricwar_name': None,
                'team': row['Team'],
                'price_cr': row['price_cr'],
                'total_WAR': 0.0,
                'batting_WAR': 0.0,
                'bowling_WAR': 0.0,
                'match_type': 'none'
            })
            
    result_df = pd.DataFrame(mapped_data)
    
    print(f"✓ Mapped {len(result_df) - len(unmapped)} players")
    print(f"✗ Unmapped {len(unmapped)} players")
    
    if unmapped:
        print("\nUnmapped players (Top 10):")
        for p in unmapped[:10]:
            print(f"  - {p}")
            
    return result_df

def calculate_metrics(df):
    """Calculate value metrics."""
    print("\nCalculating metrics...")
    
    # Filter to mapped players only for metric calculation
    # (Or should we keep all? If WAR is 0, metric is 0)
    # Let's keep all but handle division by zero
    
    # WAR per Crore (Higher is better)
    # Avoid division by zero price (though unlikely for sold players)
    df['war_per_crore'] = df.apply(
        lambda x: x['total_WAR'] / x['price_cr'] if x['price_cr'] > 0 else 0, axis=1
    )
    
    # Price per WAR (Lower is better)
    # Only meaningful for positive WAR
    # If WAR <= 0, it's "Infinite" or "Negative Value"
    df['price_per_1_war'] = df.apply(
        lambda x: x['price_cr'] / x['total_WAR'] if x['total_WAR'] > 0.1 else np.nan, axis=1
    )
    
    return df

def analyze_and_save(df, output_dir):
    """Generate analysis and save results."""
    print("\nGenerating analysis...")
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Save full dataset
    df.to_csv(output_dir / 'war_vs_price_full.csv', index=False)
    
    # Top Value Picks (High WAR, Low Price)
    # Filter: Price > 0.5 Cr (to avoid very cheap players skewing list?) 
    # Or just sort by WAR/Crore
    top_value = df[df['total_WAR'] > 1.0].sort_values('war_per_crore', ascending=False).head(15)
    
    print("\nTOP VALUE PICKS (Min 1.0 WAR):")
    print(top_value[['price_name', 'team', 'price_cr', 'total_WAR', 'war_per_crore']].to_string(index=False))
    top_value.to_csv(output_dir / 'top_value_picks.csv', index=False)
    
    # Worst Value Picks (High Price, Low WAR)
    # Filter: Price > 5 Cr
    worst_value = df[df['price_cr'] > 5.0].sort_values('war_per_crore', ascending=True).head(15)
    
    print("\nWORST VALUE PICKS (Price > 5 Cr):")
    print(worst_value[['price_name', 'team', 'price_cr', 'total_WAR', 'war_per_crore']].to_string(index=False))
    worst_value.to_csv(output_dir / 'worst_value_picks.csv', index=False)
    
    # Team Efficiency
    team_stats = df.groupby('team').agg({
        'price_cr': 'sum',
        'total_WAR': 'sum',
        'price_name': 'count'
    }).reset_index()
    team_stats['war_per_crore'] = team_stats['total_WAR'] / team_stats['price_cr']
    team_stats = team_stats.sort_values('war_per_crore', ascending=False)
    
    print("\nTEAM EFFICIENCY:")
    print(team_stats[['team', 'price_cr', 'total_WAR', 'war_per_crore']].to_string(index=False))
    team_stats.to_csv(output_dir / 'team_efficiency.csv', index=False)
    
    print(f"\n✓ Results saved to {output_dir}")

def main():
    project_root = Path(__file__).parent.parent
    output_dir = project_root / 'results' / '11_war_vs_price'
    
    # Load
    prices, batter_war, bowler_war, metadata = load_data(project_root)
    
    # Map
    merged_df = map_players(prices, batter_war, bowler_war, metadata)
    
    # Calculate
    final_df = calculate_metrics(merged_df)
    
    # Analyze
    analyze_and_save(final_df, output_dir)

if __name__ == "__main__":
    main()
